#+TITLE: Lists

/Borrowed in large part from Samuel Rebelsky's 151 2019 spring course web site,
[[https://www.cs.grinnell.edu/~rebelsky/Courses/CSC151/2019S/readings/list-basics.html][here]], [[https://www.cs.grinnell.edu/~rebelsky/Courses/CSC151/2019S/readings/homogeneous-lists.html][here]], and [[https://www.cs.grinnell.edu/~rebelsky/Courses/CSC151/2019S/readings/homogeneous-lists.html][here]]./

* Introduction

In your initial explorations with elm you have investigated a variety of basic types of data, including ~Int~ s, ~String~ s, and ~Bool~ s, as well as some more complicated ones, like ~List~ s, functions, and the ever mysterious ~Html~. You can work on many kinds of problems with just these types. However, when you want to address more complex problems, you will need a solid understanding of both the fundamentals of lists and how to manipulate them.

You may recall that there are five basic issues we should consider when we encounter a new type: its name, its purpose, how one expresses values in the type, how the computer displays values in the type, and what operations are available to you. (It may seem that we are repeating this list of issues; that’s because we want you to accustom yourself to asking about those five issues each time you encounter or design a new type.)


* List Basics
** Creating lists
We already have the type's name, ~List~, so how about we look at some values.
The easiest way to create a list is with list literals, like we have already
seen:

#+BEGIN_SRC elm
> counting = [1.0,2.0,3.0]
 [1,2,3] : List Float
> ['a', 'b', 'c']
 ['a', 'b', 'c'] : List Char
> ["I'm all alone :("]
 ["I'm all alone :("] : List String
> whoHappy = [("Grumpy Cat", False), ("Pharrell", True)]
 [("Grumpy Cat", False), ("Pharrell", True)] : List (String, Bool)
#+END_SRC

Notice that all of the lists above only contain values of one type. Let's try building a list with multiple different types of values in it:

#+BEGIN_SRC elm
> [0.90, " percent of statistics are made up on the spot"]
-- TYPE MISMATCH ---------------------------------------------------------- REPL

The 2nd element of this list does not match all the previous elements:

3|   [0.90, " percent of statistics are made up on the spot"]
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The 2nd element is a string of type:

    String

But all the previous elements in the list are:

    Float

Hint: Everything in a list must be the same type of value. This way, we never
run into unexpected values partway through a List.map, List.foldl, etc. Read
<https://elm-lang.org/0.19.1/custom-types> to learn how to “mix” types.

Hint: Want to convert a String into a Float? Use the String.toFloat function!
#+END_SRC

EMPTY LIST EXPLANATION

We can also construct lists with functions, like ~singleton~, ~repeat~, and
~range~:

,#+BEGIN_SRC elm
> List.singleton 3.14
 [3.14] : List Float
> List.repeat 3 "Run away!"
 ["Run away!", "Run away!", "Run away!"] : List String
> List.range 0 4
 [0, 1, 2, 3, 4] : List Int
> List.range 4 0
 [] : List Int
#+END_SRC

** Strings and lists
You may be asking yourself at this point why we have a ~String~ type if we also have lists of ~Char~ s. Both data types hold

** Some List operations

Lists can be put together with the ~++~ and ~append~ functions:

#+BEGIN_SRC elm
> ['h'] ++ ['i'] ++ ['j']
 ['h', 'i', 'j'] : List Char
> append ["Hello", "there"] ["General", "Kenobi"]
 ["Hello", "there", "General", "Kenobi"] : List String
> ["We're", "the"] ++ ["same!"]
 ["We're", "the", "same!"] : List String
> append ["We're", "the"] ["same!"]
 ["We're", "the", "same!"] : List String
#+END_SRC


We can pull values out of lists using ~List.take~ and ~List.head~:

#+BEGIN_SRC elm
> List.take 3 ["You'll", "never", "take", "me!"]
 ["You'll", "never", "take"] : List String
> List.take 8 [1.1,2.2,3.3]
 [1.1, 2.2, 3.3] : List Float
> List.head ["Sandals", "are" ++ "n't", "food"]
 Just "Sandals" : Maybe String
> List.head []
 Nothing : Maybe String
#+END_SRC

Remove them with ~List.drop~ and ~List.tail~:

#+BEGIN_SRC elm
> List.drop 2 [1 - 0.1, 2, 3, 4 + 1]
 [3,5] : List Float
> List.drop 5 [[], [], ["aaaaaah", "ha", "ha", "ha", "haa"]]
 [] : List (List String)
> List.tail ["potato", "salad", "bowl"]
 Just ["salad", "bowl"] : List String
> List.tail ["curry"]
 Just [] : List String
> List.tail (List.drop 2 ['a', 'b'])
 Nothing : List Char
#+END_SRC

And reverse them with ~List.reverse~:

#+BEGIN_SRC elm
> List.reverse ["elm", "is", "great"]
 ["great", "is", "elm"] : List String
> List.reverse (List.range 1 -1)
 [-1,0,1] : List Int
> List.reverse [[1,2,3], [3,2,1]]
 [[3,2,1],[1,2,3]] : List number
#+END_SRC

** Self-check:
1. Predict the results of evaluating the following expressions:
    #+BEGIN_SRC elm
    [2,1]
    List.singleton 1.12
    List.append [1] [2]
    List.append [2, 1] [2, 1]
    List.range -3 0
    List.range 0 3
    List.range 0 0
    List.drop 2 [1, 2, 3]
    List.tail (["a"] ++ ["b"])
    #+END_SRC
1. With only the functions listed above, and no list literals, make the list
   ~[1,2,6,5,4]~
** Homework:
1. Write a function
   #+BEGIN_SRC elm
   at : Int -> List Char -> Maybe Char
   at index lst =
       -- Your code here
   #+END_SRC
   ~at : Int -> List Char -> Maybe Char~
   that returns the value in ~lst~ at the position given by the ~index~, if
   there is one there.
